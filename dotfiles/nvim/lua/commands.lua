print "creating user commands"
-- I feel that a wrapper for this function is justified since the error
-- messages so far only mention the type, and nothing else to give context
-- except a file and line number
local def = vim.api.nvim_create_user_command
def("W", "w", {})
def("Q", "q", {})
def("Wq", "wq", {})
def("WQ", "wq", {})
if vim.fn.has("win32") then
  def(
    "StartSsh",
    function(_)
      vim.api.nvim_command"cd ~"
      vim.api.nvim_command"!powershell -c Start-Ssh"
      vim.api.nvim_command"cd-"
    end,
    {
      desc = "Calls the PowerShell profile-defined Start-Ssh",
  })
end

--[[ A lesson in overdoing it:
-- This used to be much more complicated.
-- The error messages were interpretable, but the error messages generated by
-- calling the function directly point to the exact line and file already, and
-- those hopefully give enough context.
local commands = {
  {"W", "w"},
  {"Q", "q"},
  {"Wq", "wq"},
  {1, 'echom "hello!"'},
  {"WQ", "wq"},
}

for i, tbl in ipairs(commands) do
  local i = "command #"..tostring(i)
  assert(
    #tbl == 2 or #tbl == 3,
    i.." is not a table of two or three elements elements"
  )

  local name = tbl[1]
  local command = tbl[2]
  local opts = tbl[3] or {}

  assert(
    type(name) == "string",
    i..": first element must be a string"
  )
  assert(
    type(command) == "string" or type(command) == "function",
    i..": second element must be a string or function"
  )
  assert(
    type(opts) == "table",
    i..": third (optional) element must be a table"
  )

  def(name, command, opts)
end
--]]
